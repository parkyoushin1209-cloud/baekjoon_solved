from collections import deque
k = int(input())
def bfs(x):
    q = deque()
    q.append((x,1))
    result[x] = 1
    while q:
        now, prev = q.popleft()
        idx = 1 if prev == 2 else 2
        for i in graph[now]:
            if result[i] == -1:
                result[i] = idx
                q.append((i,idx))
            else:
                if result[i] != idx:
                    return 0
    return 1
for _ in range(k):
    v, e = map(int,input().split())
    graph = [[] for _ in range(v+1)]
    result = [-1 for _ in range(v+1)]
    for _ in range(e):
        a, b = map(int,input().split())
        graph[a].append(b)
        graph[b].append(a)
    check = 1
    for p in range(1,v+1):
        if result[p] == -1:
            m = bfs(p)
            if m == 0:
                check = 0
    if check == 0:
        print("NO")
    else:
        print("YES")
##이분 그래프: 2가지 색으로 이웃한 노드의 색이 겹치지 않도록 적용 가능?
## 1-2-3 O  1-2-3-4-2 X
## 간소화 버전
def bfs(start):
    q = deque([start])
    color[start] = 1
    while q:
        node = q.popleft()
        for neighbor in graph[node]:
            if color[neighbor] == 0:
                color[neighbor] = 3 - color[node]  # 1↔2
                q.append(neighbor)
            elif color[neighbor] == color[node]:
                return False
    return True

for i in range(1, v + 1):
        if color[i] == 0 and not bfs(i):
            result = False
            break

print("YES" if result else "NO")
