#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>


void merge(int* arr, int l, int m, int r) {
	int len1 = m - l + 1, len2 = r - m;
	int* left = (int*)malloc(len1 * sizeof(int));
	int* right = (int*)malloc(len2 * sizeof(int));
	
	for (int i = 0; i < len1; i++)left[i] = arr[l + i];
	for (int i = 0; i < len2; i++)right[i] = arr[m + i + 1];

	int i = 0, j = 0, k = l;
	while (i < len1 && j < len2) {
		if (left[i] <= right[j])arr[k++] = left[i++];
		else arr[k++] = right[j++];
	}

	while (i < len1)arr[k++] = left[i++];
	while (j < len2)arr[k++] = right[j++];

	free(left);
	free(right);
}

void mergesort(int* arr, int left, int right) {
	if (left < right) {
		int mid = (left + right) / 2;
		mergesort(arr, left, mid);
		mergesort(arr, mid + 1, right);
		merge(arr, left, mid, right);
	}
}// 병합 정렬 사용 => n의 범위가 10000 => 퀵 정렬 사용시 최악의 경우  시간 복잡도 O(n^2)이어서 시간 초과
/// 시간 복잡도 O(nlogn)을 보장해주는 병합 정렬 사

int main() {
	int n;
	scanf("%d", &n);
	int* data = (int*)malloc(n * sizeof(int));
	for (int i = 0; i < n; i++)
		scanf("%d", &data[i]);

	mergesort(data, 0, n - 1);

	long long cnt = 0; // n이 범위가 큼 => long long이 안전
	for (int i = 0; i < n - 2; i++) {
		int first = data[i];
		int l = i + 1, r = n - 1;// 중복되는 항 방지 => l 은 i+1부터

		while (l < r) {
			int sum = first + data[l] + data[r];
			if (sum == 0) {
				if (data[l] == data[r]) {
					long long length = r - l + 1;
					cnt += length * (length - 1) / 2;  // 두 포인터가 가리키는 값이 같다면 그 값이 개수를 구한 뒤 조합 사용
					break;  // 정렬 완료된 상태 => l, r이 같다면 그 수들의 연속이 가장 마지막 => break 사용 가능
				}
				else {
					long long cntl = 1, cntr = 1;
					while (l + 1 < r && data[l] == data[l + 1]) cntl++, l++;
					while (r - 1 > l && data[r] == data[r - 1]) cntr++, r--; //각각의 수에 대해 얼마나 연속되있는지 확인
					cnt += cntl * cntr;
					l++;
					r--; // 마지막 가리키는 값이 남아 있어 -- 하지 않으면 한 번 더 카운트됨
				}
			}
			else if (sum < 0) l++; // 합이 작으면 l을 키워 음수의 절댓값을 감소시키거나 양수의 크기를 키워줌
			else r--; // 합이 더 큰 경우 더 작은 수를 더해줌
		}
	}
	printf("%lld\n", cnt);
	free(data);
	return 0;
}

